# -*- coding: utf-8 -*-
"""dataloader.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tgaaPSl6Ua1ArCV1o6qBcM9P4PtRSqUg
"""

import os
import pickle
import numpy as np
from PIL import Image
from scipy import misc
import torch.utils.data as data
import torch
from torchvision.transforms import Compose, ToTensor
import random

class DatasetFromFolder(data.Dataset):
        def __init__(self,dataset,foldername,labelfolder,imgtype='png',scale_size=(64,128),
                     is_training=True):
                super(DatasetFromFolder,self).__init__()

                self.is_training = is_training

                self.imgtype = imgtype
                self.scale_size = scale_size
                self.folder = foldername
                self.dataset = dataset

                if self.dataset == 'CERUG-EN':
                    self.cerug = True
                else:
                    self.cerug = False

                #self.labelidx_name = labelfolder + dataset + 'writer_index_table.pickle'
                self.labelidx_name = 'wsegs_writer_index_table.pickle'
                print(self.labelidx_name)

                self.imglist = self._get_image_list(self.folder)
                #print(self.imglist)

                self.idlist = self._get_all_identity()
                #print(self.idlist)

                self.idx_tab = self._convert_identity2index(self.labelidx_name)

                self.num_writer = len(self.idx_tab)

                #------------ print info.
                print('-'*10)
                print('loading dataset %s with images: %d'%(dataset,len(self.imglist)))
                print('number of writer is: %d'%len(self.idx_tab))
                print('-*'*10)

                #self.trans = True



        # convert to idx for neural network
        def _convert_identity2index(self,savename):
                if os.path.exists(savename):
                        with open(savename,'rb') as fp:
                                identity_idx = pickle.load(fp)
                else:
                        #'''
                        identity_idx = {}
                        for idx,ids in enumerate(self.idlist):
                                identity_idx[ids] = idx

                        with open(savename,'wb') as fp:
                                pickle.dump(identity_idx,fp)
                        #'''

                return identity_idx

        # get all writer identity
        def _get_all_identity(self):
                writer_list = []
                for img in self.imglist:
                        writerId = self._get_identity(img)
                        writer_list.append(writerId)
                writer_list=list(set(writer_list))
                return writer_list

        def _get_identity(self,fname):
                if self.cerug:
                        return fname.split('_')[0]
                else: return fname.split('_')[0]

        # get all image list
        def _get_image_list(self,folder):
                flist = os.listdir(folder)
                imglist = []
                for img in flist:
                        if img.endswith(self.imgtype):
                                imglist.append(img)
                return imglist

        def transform(self):
                return Compose([ToTensor(),])

        def resize(self,image):
                w,h = image.size[:2]
                ratio_h = float(self.scale_size[0])/float(h)
                ratio_w = float(self.scale_size[1])/float(w)

                if ratio_h < ratio_w:
                        ratio = ratio_h
                        hfirst = False
                else:
                        ratio = ratio_w
                        hfirst = True

                nh = int(ratio * h)
                nw = int(ratio * w)

                imre = image.resize((nw, nh))
                #imre = misc.imresize(image,(nh,nw))
                im_array = np.array(imre)

                # Invert the image
                im_array = 255 - im_array
                imre = Image.fromarray(im_array)

                if imre is None:
                  raise ValueError("The 'imre' variable is not defined.")

                if not isinstance(imre, Image.Image):
                  raise TypeError("The 'imre' variable is not an image.")

                try:
                  imre.verify()
                except Exception as e:
                  raise ValueError("The image data in 'imre' is corrupted.") from e
                #imre = 255 - imre

                cw, ch = imre.size
                if self.is_training:
                    new_img = np.zeros(self.scale_size)
                    dy = int((self.scale_size[0]-ch))
                    dx = int((self.scale_size[1]-cw))
                    dy = random.randint(0,dy)
                    dx = random.randint(0,dx)
                else:
                    new_img = np.zeros(self.scale_size)
                    dy = int((self.scale_size[0]-ch)/2.0)
                    dx = int((self.scale_size[1]-cw)/2.0)

                #new_img = np.zeros(self.scale_size)
                #dy = int((self.scale_size[0]-ch)/2.0)
                #dx = int((self.scale_size[1]-cw)/2.0)

                imre = imre.convert('F')
                #imre = imre.astype('float')

                new_img[dy:dy+ch,dx:dx+cw] = imre
                #new_img /= 256.0
                #print(new_img.shape)

                return new_img,hfirst


        def __getitem__(self,index):

                imgfile = self.imglist[index]
                writer = self.idx_tab[self._get_identity(imgfile)]

                image = Image.open(self.folder + imgfile).convert('L')
                image,hfirst = self.resize(image)
                image = image / 255.0

                image = self.transform()(image)
                writer = torch.from_numpy(np.array(writer))

                return image,writer,imgfile

        def __len__(self):
                return len(self.imglist)